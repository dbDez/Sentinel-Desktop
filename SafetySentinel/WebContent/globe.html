<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SENTINEL Globe</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e17; overflow: hidden; font-family: 'Consolas', monospace; }
        #globe-container { width: 100vw; height: 100vh; }
        canvas { display: block; }

        #tooltip {
            position: absolute; display: none;
            background: rgba(17,24,39,0.95); border: 1px solid #00ff88;
            border-radius: 6px; padding: 10px 14px; color: #e5e7eb;
            font-size: 12px; pointer-events: none; z-index: 100; max-width: 280px;
        }
        #tooltip .country-name { font-size: 14px; font-weight: bold; color: #00ff88; margin-bottom: 6px; }
        #tooltip .score-row { display: flex; justify-content: space-between; margin: 2px 0; }
        #tooltip .score-label { color: #9ca3af; }
        #tooltip .score-value { font-weight: bold; }

        #continent-buttons {
            position: absolute; bottom: 20px; left: 20px;
            display: flex; gap: 6px; z-index: 50;
        }
        .continent-btn {
            background: rgba(26,31,46,0.9); border: 1px solid #1e293b;
            color: #e5e7eb; padding: 6px 12px; border-radius: 4px;
            cursor: pointer; font-size: 11px; font-family: 'Consolas', monospace; transition: all 0.2s;
        }
        .continent-btn:hover { border-color: #00ff88; color: #00ff88; background: rgba(0,255,136,0.1); }
        .continent-btn.active { border-color: #00ff88; color: #00ff88; background: rgba(0,255,136,0.2); }

        #controls {
            position: absolute; top: 10px; right: 10px;
            display: flex; flex-direction: column; gap: 6px; z-index: 50;
        }
        #info-panel {
            background: rgba(17,24,39,0.9); border: 1px solid #1e293b;
            border-radius: 6px; padding: 10px; color: #9ca3af; font-size: 10px;
        }
        .ctrl-btn {
            background: rgba(26,31,46,0.9); border: 1px solid #1e293b;
            color: #9ca3af; padding: 6px 12px; border-radius: 4px;
            cursor: pointer; font-size: 11px; font-family: 'Consolas', monospace; transition: all 0.2s;
        }
        .ctrl-btn:hover { border-color: #00ff88; color: #00ff88; }
        .ctrl-btn.active { background: rgba(0,255,136,0.15); border-color: #00ff88; color: #00ff88; }

        /* ===== THREAT SIDEBAR ===== */
        #threat-sidebar {
            position: absolute; top: 0; right: -380px; width: 380px; height: 100%;
            background: rgba(17,24,39,0.97); border-left: 1px solid #1e293b;
            z-index: 200; transition: right 0.35s ease; overflow-y: auto;
            padding: 16px; display: flex; flex-direction: column;
        }
        #threat-sidebar.open { right: 0; }
        #sidebar-close {
            position: absolute; top: 10px; right: 14px;
            background: none; border: 1px solid #1e293b; color: #9ca3af;
            font-size: 18px; cursor: pointer; border-radius: 4px; width: 28px; height: 28px;
            display: flex; align-items: center; justify-content: center; transition: all 0.2s;
        }
        #sidebar-close:hover { border-color: #ef4444; color: #ef4444; }
        #sidebar-country { font-size: 18px; font-weight: bold; color: #00ff88; margin-bottom: 4px; margin-right: 40px; }
        #sidebar-code { font-size: 12px; color: #9ca3af; margin-bottom: 16px; }
        .domain-row { margin-bottom: 14px; }
        .domain-label { font-size: 11px; color: #9ca3af; margin-bottom: 3px; display: flex; justify-content: space-between; }
        .domain-score { font-weight: bold; }
        .threat-bar {
            width: 100%; height: 12px; border-radius: 6px; position: relative;
            border: 1px solid rgba(255,255,255,0.06); overflow: hidden;
        }
        .threat-bar-fill {
            width: 100%; height: 100%;
            border-radius: 6px;
        }

        #sidebar-badge {
            margin-top: auto; padding: 10px; border-radius: 6px; text-align: center;
            font-size: 16px; font-weight: bold;
        }
        .sidebar-section { font-size: 11px; color: #fbbf24; font-weight: bold; margin: 12px 0 6px; }
        .sidebar-detail { font-size: 11px; color: #9ca3af; margin: 3px 0; display: flex; justify-content: space-between; }
        .sidebar-detail span:last-child { color: #e5e7eb; font-weight: bold; }

        #watermark {
            position: absolute; bottom: 20px; right: 20px; opacity: 0.35;
            pointer-events: none; z-index: 50;
        }
        #watermark img { filter: drop-shadow(0 0 8px rgba(0,255,136,0.3)); }

        #brief-label {
            position: absolute; top: 58px; left: 12px;
            color: #4b5563; font-size: 10px; font-family: 'Consolas', monospace;
            pointer-events: none; z-index: 40;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>
    <div id="globe-container"></div>
    <div id="tooltip"></div>
    <div id="brief-label"></div>

    <div id="continent-buttons">
        <button class="continent-btn" data-continent="Africa" onclick="flyToContinent('Africa', this)">Africa</button>
        <button class="continent-btn" data-continent="Asia" onclick="flyToContinent('Asia', this)">Asia</button>
        <button class="continent-btn" data-continent="Europe" onclick="flyToContinent('Europe', this)">Europe</button>
        <button class="continent-btn" data-continent="NAmerica" onclick="flyToContinent('NAmerica', this)">N.America</button>
        <button class="continent-btn" data-continent="SAmerica" onclick="flyToContinent('SAmerica', this)">S.America</button>
        <button class="continent-btn" data-continent="Oceania" onclick="flyToContinent('Oceania', this)">Oceania</button>
        <button class="ctrl-btn" onclick="showAll()">🌐 Show All</button>
    </div>

    <div id="controls">
        <div id="info-panel">
            <div>Drag to rotate | Scroll to zoom</div>
            <div>Click country marker for details</div>
        </div>
        <button class="ctrl-btn active" id="rotate-btn" onclick="toggleAutoRotate()">⟳ Auto Rotate</button>
    </div>

    <!-- Threat Sidebar -->
    <div id="threat-sidebar">
        <button id="sidebar-close" onclick="closeSidebar()">✕</button>
        <div id="sidebar-country"></div>
        <div id="sidebar-code"></div>
        <div id="sidebar-domains"></div>
        <div id="sidebar-extras"></div>
        <div id="sidebar-badge"></div>
    </div>

    <div id="watermark">
        <img src="Sentinel.png" alt="Sentinel" width="48" height="48"/>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, globeGroup, globe, countryMarkers = [], hotspotMarkers = [];
        let threatRings = [];
        let countryData = [], hotspotData = [];
        let autoRotate = true, isDragging = false, isAnimating = false;
        let previousMouse = { x: 0, y: 0 };
        let dragStartTime = 0;
        let dragMode = 'normal'; // 'normal', 'zroll-left', or 'zroll-right'
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const GLOBE_RADIUS = 5;
        const MARKER_SIZE = 0.1;
        const DEFAULT_ZOOM = 15;
        const CONTINENT_ZOOM = 9;
        const DEG = Math.PI / 180;

        // Camera distance
        let cameraDistance = DEFAULT_ZOOM;

        // Current globe orientation — tracked for fly-to starting position
        let currentLat = 0;
        let currentLon = 0;

        // Momentum / inertia
        let velocityX = 0;
        let velocityY = 0;
        const FRICTION = 0.95;
        const MIN_VELOCITY = 0.0001;

        // Globe readiness
        let globeReady = false;

        // LOD texture management — loaded lazily AFTER globe is interactive
        let currentLOD = 0;
        let globeMaterial = null;
        const textureLoader = new THREE.TextureLoader();
        let maxAniso = 1;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0e17);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, DEFAULT_ZOOM);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('globe-container').appendChild(renderer.domElement);

            maxAniso = renderer.capabilities.getMaxAnisotropy();

            scene.add(new THREE.AmbientLight(0xffffff, 1.2));
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(5, 3, 5);
            scene.add(sunLight);

            globeGroup = new THREE.Group();
            scene.add(globeGroup);

            // Earth — show a dark globe immediately, then swap texture when CDN loads
            const globeGeometry = new THREE.SphereGeometry(GLOBE_RADIUS, 128, 128);
            globeMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color(0x0a1628),
                specular: new THREE.Color(0x111827),
                shininess: 8,
                emissive: new THREE.Color(0x050d18),
                emissiveIntensity: 0.3
            });
            globe = new THREE.Mesh(globeGeometry, globeMaterial);
            globeGroup.add(globe);

            // Add wireframe grid overlay so globe is visible immediately
            const wireGeo = new THREE.SphereGeometry(GLOBE_RADIUS + 0.02, 36, 18);
            const wireMat = new THREE.MeshBasicMaterial({
                color: 0x1a3a5c, wireframe: true, transparent: true, opacity: 0.25
            });
            const wireGlobe = new THREE.Mesh(wireGeo, wireMat);
            globeGroup.add(wireGlobe);

            // Globe is usable immediately — signal ready NOW before textures load
            globeReady = true;
            window.chrome.webview.postMessage('GLOBE_READY');

            // Load textures asynchronously — swap them in when downloaded
            textureLoader.load(
                'https://unpkg.com/three-globe@2.31.1/example/img/earth-blue-marble.jpg',
                function(tex) {
                    tex.anisotropy = maxAniso;
                    globeMaterial.map = tex;
                    globeMaterial.color = new THREE.Color(0.55, 0.55, 0.65);
                    globeMaterial.emissive = new THREE.Color(0x000000);
                    globeMaterial.emissiveIntensity = 0;
                    globeMaterial.needsUpdate = true;
                    // Fade out wireframe
                    wireGlobe.material.opacity = 0;
                    wireGlobe.visible = false;
                }
            );
            textureLoader.load(
                'https://unpkg.com/three-globe@2.31.1/example/img/earth-topology.png',
                function(tex) {
                    tex.anisotropy = maxAniso;
                    globeMaterial.bumpMap = tex;
                    globeMaterial.bumpScale = 0.05;
                    globeMaterial.needsUpdate = true;
                }
            );

            // Atmosphere glow
            const atmosGeo = new THREE.SphereGeometry(GLOBE_RADIUS + 0.15, 64, 64);
            const atmosMat = new THREE.MeshBasicMaterial({
                color: 0x4488ff, transparent: true, opacity: 0.08, side: THREE.BackSide
            });
            scene.add(new THREE.Mesh(atmosGeo, atmosMat));

            // Stars
            const starsGeo = new THREE.BufferGeometry();
            const positions = [];
            for (let i = 0; i < 3000; i++) {
                positions.push((Math.random()-0.5)*300, (Math.random()-0.5)*300, (Math.random()-0.5)*300);
            }
            starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            scene.add(new THREE.Points(starsGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.08, transparent: true, opacity: 0.6 })));

            // Set initial rotation to show Africa/Europe on load
            currentLat = 0;
            currentLon = 0;
            setGlobeToLatLon(0, 0);

            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mouseleave', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('click', onClick);
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        // ===== LOD texture management — loaded lazily after markers are shown =====
        let lodLoaded = false;
        const LOD_TEXTURES = [
            { zoom: 25, tex: null, bump: null, loaded: true }, // LOD 0 = base texture (already loaded)
            { zoom: 11, tex: null, bump: null, loaded: false,
              url: 'https://unpkg.com/three-globe@2.31.3/example/img/earth-blue-marble.jpg',
              bumpUrl: 'https://unpkg.com/three-globe@2.31.3/example/img/earth-topology.png' },
            { zoom: 7, tex: null, bump: null, loaded: false,
              url: 'https://unpkg.com/three-globe@2.34.2/example/img/earth-blue-marble.jpg',
              bumpUrl: 'https://unpkg.com/three-globe@2.34.2/example/img/earth-topology.png' },
            { zoom: 5, tex: null, bump: null, loaded: false,
              url: 'https://eoimages.gsfc.nasa.gov/images/imagerecords/74000/74218/world.200412.3x5400x2700.jpg',
              bumpUrl: 'https://unpkg.com/three-globe@2.34.2/example/img/earth-topology.png' }
        ];

        function startLODPreload() {
            if (lodLoaded) return;
            lodLoaded = true;
            // LOD 0 is already the base texture on the globe
            LOD_TEXTURES[0].tex = globeMaterial.map;
            LOD_TEXTURES[0].bump = globeMaterial.bumpMap;

            for (let i = 1; i < LOD_TEXTURES.length; i++) {
                (function(idx) {
                    textureLoader.load(LOD_TEXTURES[idx].url, function(tex) {
                        tex.anisotropy = maxAniso;
                        LOD_TEXTURES[idx].tex = tex;
                        LOD_TEXTURES[idx].loaded = true;
                    });
                    textureLoader.load(LOD_TEXTURES[idx].bumpUrl, function(tex) {
                        tex.anisotropy = maxAniso;
                        LOD_TEXTURES[idx].bump = tex;
                    });
                })(i);
            }
        }

        function updateLOD() {
            let bestLOD = 0;
            for (let i = LOD_TEXTURES.length - 1; i >= 0; i--) {
                if (cameraDistance <= LOD_TEXTURES[i].zoom && LOD_TEXTURES[i].loaded && LOD_TEXTURES[i].tex) {
                    bestLOD = i;
                    break;
                }
            }
            if (bestLOD !== currentLOD && LOD_TEXTURES[bestLOD].tex) {
                currentLOD = bestLOD;
                globeMaterial.map = LOD_TEXTURES[bestLOD].tex;
                globeMaterial.map.needsUpdate = true;
                if (LOD_TEXTURES[bestLOD].bump) {
                    globeMaterial.bumpMap = LOD_TEXTURES[bestLOD].bump;
                    globeMaterial.bumpMap.needsUpdate = true;
                }
                globeMaterial.needsUpdate = true;
            }
        }

        // ===== Marker scaling =====
        // Country markers and hotspot markers scale inversely to zoom so they stay visually constant.
        // Threat rings ALSO scale inversely so they remain a fixed screen size when zooming.
        function getMarkerScale() {
            return cameraDistance / DEFAULT_ZOOM;
        }

        function updateMarkerScales() {
            const s = getMarkerScale();
            countryMarkers.forEach(m => {
                m.scale.set(s, s, s);
            });
            hotspotMarkers.forEach(m => {
                m.scale.set(s, s, s);
            });
            threatRings.forEach(m => {
                m.scale.set(s, s, s);
            });
        }

        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * DEG;
            const theta = (lon + 180) * DEG;
            return new THREE.Vector3(
                -(radius * Math.sin(phi) * Math.cos(theta)),
                radius * Math.cos(phi),
                radius * Math.sin(phi) * Math.sin(theta)
            );
        }

        // Build a quaternion for a given lat/lon that guarantees NO Z-roll.
        function quaternionForLatLon(lat, lon) {
            const qY = new THREE.Quaternion();
            qY.setFromAxisAngle(new THREE.Vector3(0, 1, 0), -(90 + lon) * DEG);
            const qX = new THREE.Quaternion();
            qX.setFromAxisAngle(new THREE.Vector3(1, 0, 0), lat * DEG);
            const q = qY.clone();
            q.premultiply(qX);
            return q;
        }

        function setGlobeToLatLon(lat, lon) {
            currentLat = lat;
            currentLon = lon;
            globeGroup.quaternion.copy(quaternionForLatLon(lat, lon));
        }

        // Extract current lat/lon from the globe quaternion (needed after drag/momentum/auto-rotate
        // which operate on quaternions directly and may leave currentLat/currentLon stale).
        function getCurrentLatLon() {
            const q = globeGroup.quaternion.clone().invert();
            const v = new THREE.Vector3(0, 0, GLOBE_RADIUS).applyQuaternion(q);
            const r = GLOBE_RADIUS;
            const lat = Math.asin(Math.max(-1, Math.min(1, v.y / r))) / DEG;
            const sinPhi = Math.sqrt(1 - (v.y/r)*(v.y/r));
            let lon = 0;
            if (sinPhi > 0.001) {
                lon = Math.atan2(v.z, -v.x) / DEG - 180;
            }
            while (lon > 180) lon -= 360;
            while (lon < -180) lon += 360;
            return { lat, lon };
        }

        // Called from C# to set the home position (gentle smooth animation, zooms in close)
        // Auto-rotate resumes after the fly animation completes.
        function setHomePosition(lat, lon) {
            smoothFlyTo(lat, lon, CONTINENT_ZOOM, 0.012);
        }

        function getThreatColor(score) {
            if (score >= 76) return 0xef4444;
            if (score >= 51) return 0xf97316;
            if (score >= 26) return 0xfbbf24;
            return 0x00ff88;
        }
        function getThreatColorCSS(score) {
            if (score >= 76) return '#ef4444';
            if (score >= 51) return '#f97316';
            if (score >= 26) return '#fbbf24';
            return '#00ff88';
        }
        function getThreatLevel(score) {
            if (score >= 76) return 'RED';
            if (score >= 51) return 'ORANGE';
            if (score >= 26) return 'YELLOW';
            return 'GREEN';
        }
        function getThreatLabel(score) {
            if (score >= 86) return 'Extreme Risk';
            if (score >= 71) return 'Severe Risk';
            if (score >= 56) return 'High Risk';
            if (score >= 41) return 'Elevated Risk';
            if (score >= 26) return 'Moderate Risk';
            if (score >= 11) return 'Fairly Safe';
            return 'Minimal Risk';
        }

        // ===== Data Loading =====
        function setBriefLabel(text) {
            const el = document.getElementById('brief-label');
            if (el) el.textContent = text;
        }

        function loadCountryData(data) {
            countryData = data;
            countryMarkers.forEach(m => globeGroup.remove(m));
            countryMarkers = [];
            threatRings.forEach(m => globeGroup.remove(m));
            threatRings = [];

            data.forEach(country => {
                const pos = latLonToVector3(country.lat, country.lng, GLOBE_RADIUS + 0.01);
                // active = in the watchlist for this brief; inactive = faint grey dot only
                const active = country.active !== false; // default true if not specified
                const color = active ? getThreatColor(country.overall) : 0x2a3040;
                const markerSize = active ? MARKER_SIZE : MARKER_SIZE * 0.5;
                const opacity = active ? 1.0 : 0.25;

                const geo = new THREE.SphereGeometry(markerSize, 12, 12);
                const mat = new THREE.MeshBasicMaterial({ color: color, transparent: !active, opacity: opacity });
                const marker = new THREE.Mesh(geo, mat);
                marker.position.copy(pos);
                marker.userData = country;
                globeGroup.add(marker);
                countryMarkers.push(marker);

                // Threat rings only for active watched countries with significant threat
                if (active && country.overall >= 51) {
                    const ringGeo = new THREE.RingGeometry(MARKER_SIZE * 1.5, MARKER_SIZE * 2.2, 32);
                    const ringMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.4, side: THREE.DoubleSide });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.position.copy(pos);
                    ring.lookAt(new THREE.Vector3(0,0,0));
                    globeGroup.add(ring);
                    threatRings.push(ring);
                }
            });

            updateMarkerScales();

            // Start preloading higher LOD textures now that markers are visible
            setTimeout(startLODPreload, 500);
        }

        function loadHotspotData(data) {
            hotspotData = data;
            hotspotMarkers.forEach(m => globeGroup.remove(m));
            hotspotMarkers = [];

            data.forEach(hotspot => {
                const pos = latLonToVector3(hotspot.lat, hotspot.lng, GLOBE_RADIUS + 0.02);
                const geo = new THREE.SphereGeometry(MARKER_SIZE * 0.5, 6, 6);
                const mat = new THREE.MeshBasicMaterial({ color: 0xff2222, transparent: true });
                const marker = new THREE.Mesh(geo, mat);
                marker.position.copy(pos);
                marker.userData = { ...hotspot, isHotspot: true };
                globeGroup.add(marker);
                hotspotMarkers.push(marker);
            });

            updateMarkerScales();
        }

        // ===== Continent Selection & Fly-To =====
        // Bounding boxes: center lat/lon and zoom distance to fit the entire continent
        const CONTINENT_BOUNDS = {
            'Africa':   { lat:  2,  lon: 22,  zoom: 11.5 }, // 37°N to 35°S, 17°W to 51°E
            'Asia':     { lat: 30,  lon: 85,  zoom: 10.5 }, // 1°N to 55°N, 25°E to 150°E — largest continent
            'Europe':   { lat: 52,  lon: 18,  zoom: 11.0 }, // 35°N to 72°N, 10°W to 45°E
            'NAmerica': { lat: 45,  lon: -100, zoom: 11.0 },// 7°N to 84°N, 170°W to 25°W
            'SAmerica': { lat: -15, lon: -58,  zoom: 11.5 },// 12°N to 56°S, 82°W to 35°W
            'Oceania':  { lat: -22, lon: 140,  zoom: 11.0 } // 10°N to 47°S, 110°E to 180°E
        };

        function flyToContinent(name, btn) {
            document.querySelectorAll('.continent-btn').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');
            closeSidebar();
            velocityX = 0;
            velocityY = 0;

            const bounds = CONTINENT_BOUNDS[name];
            if (bounds) {
                smoothFlyTo(bounds.lat, bounds.lon, bounds.zoom);
            }
        }

        function selectContinent(lat, lon, label, btn) {
            document.querySelectorAll('.continent-btn').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');
            velocityX = 0;
            velocityY = 0;
            smoothFlyTo(lat, lon, CONTINENT_ZOOM);
        }

        function showAll() {
            document.querySelectorAll('.continent-btn').forEach(b => b.classList.remove('active'));
            closeSidebar();
            velocityX = 0;
            velocityY = 0;
            smoothFlyTo(0, 0, DEFAULT_ZOOM);
        }

        // Smooth fly-to using lat/lon interpolation. No quaternion slerp = no Z-roll.
        function smoothFlyTo(lat, lon, zoom, speed) {
            const step_speed = speed || 0.025;
            isAnimating = true;
            // Extract real lat/lon from quaternion (may be stale after drag/momentum)
            const pos = getCurrentLatLon();
            currentLat = pos.lat;
            currentLon = pos.lon;
            const startLat = currentLat;
            const startLon = currentLon;
            const startZoom = cameraDistance;

            // Find shortest longitude path (wrap around dateline)
            let lonDiff = lon - startLon;
            if (lonDiff > 180) lonDiff -= 360;
            if (lonDiff < -180) lonDiff += 360;

            let t = 0;
            function step() {
                t += step_speed;
                if (t >= 1) {
                    t = 1;
                    setGlobeToLatLon(lat, lon);
                    cameraDistance = zoom;
                    targetZoomDistance = zoom;
                    camera.position.set(0, 0, cameraDistance);
                    camera.lookAt(0, 0, 0);
                    updateMarkerScales();
                    updateLOD();
                    isAnimating = false;
                    return;
                }
                const ease = t < 0.5 ? 2*t*t : -1+(4-2*t)*t;
                const newLat = startLat + (lat - startLat) * ease;
                const newLon = startLon + lonDiff * ease;
                setGlobeToLatLon(newLat, newLon);
                cameraDistance = startZoom + (zoom - startZoom) * ease;
                targetZoomDistance = cameraDistance;
                camera.position.set(0, 0, cameraDistance);
                camera.lookAt(0, 0, 0);
                updateMarkerScales();
                updateLOD();
                requestAnimationFrame(step);
            }
            step();
        }

        // ===== Controls =====
        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            const btn = document.getElementById('rotate-btn');
            btn.classList.toggle('active', autoRotate);
            btn.textContent = autoRotate ? '⟳ Auto Rotate' : '⟳ Rotation Off';
        }

        // ===== Drag rotation =====
        function getRadiansPerPixel() {
            const vFov = camera.fov * DEG;
            const visibleHeight = 2 * Math.tan(vFov / 2) * cameraDistance;
            const globeDiameterPx = (2 * GLOBE_RADIUS / visibleHeight) * window.innerHeight;
            return Math.PI / globeDiameterPx;
        }

        // Get the pixel X boundaries of the globe's visible disc on screen.
        function getGlobeScreenBounds() {
            const vFov = camera.fov * DEG;
            const visibleHeight = 2 * Math.tan(vFov / 2) * cameraDistance;
            const visibleWidth = visibleHeight * (window.innerWidth / window.innerHeight);
            const pxPerUnit = window.innerWidth / visibleWidth;
            const globeRadiusPx = GLOBE_RADIUS * pxPerUnit;
            const centerX = window.innerWidth / 2;
            return {
                left: centerX - globeRadiusPx,
                right: centerX + globeRadiusPx,
                centerX: centerX,
                radiusPx: globeRadiusPx
            };
        }

        // Determine drag mode based on mouse X position relative to globe edges.
        function getDragMode(clientX) {
            const bounds = getGlobeScreenBounds();
            const zZoneMargin = bounds.radiusPx * 0.5;
            const zZoneLeft = bounds.left - zZoneMargin;
            const zZoneRight = bounds.right + zZoneMargin;
            if (clientX < zZoneLeft) return 'zroll-left';
            if (clientX > zZoneRight) return 'zroll-right';
            return 'normal';
        }

        // Apply drag rotation: Y-axis (horizontal) and X-axis (vertical) in world space.
        function applyDragRotation(dx, dy) {
            const radPerPx = getRadiansPerPixel();
            const zoomFactor = cameraDistance / DEFAULT_ZOOM;
            const angleY = dx * radPerPx * zoomFactor;
            const angleX = dy * radPerPx * zoomFactor;

            if (Math.abs(angleY) > 0.000001) {
                const qY = new THREE.Quaternion();
                qY.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angleY);
                globeGroup.quaternion.premultiply(qY);
            }

            if (Math.abs(angleX) > 0.000001) {
                const qX = new THREE.Quaternion();
                qX.setFromAxisAngle(new THREE.Vector3(1, 0, 0), angleX);
                globeGroup.quaternion.premultiply(qX);
            }

            globeGroup.quaternion.normalize();
        }

        // Apply Z-axis roll rotation (for Z-roll drag zones)
        function applyZRollRotation(dy, side) {
            const radPerPx = getRadiansPerPixel();
            const direction = (side === 'zroll-right') ? -1 : 1;
            const zoomFactor = cameraDistance / DEFAULT_ZOOM;
            const angleZ = dy * radPerPx * direction * zoomFactor;
            if (Math.abs(angleZ) > 0.000001) {
                const qZ = new THREE.Quaternion();
                qZ.setFromAxisAngle(new THREE.Vector3(0, 0, 1), angleZ);
                globeGroup.quaternion.premultiply(qZ);
                globeGroup.quaternion.normalize();
            }
        }

// ===== Threat Sidebar =====
        function getThreatBarStyle(score) {
            const safeEnd = Math.max(0, 100 - score);

            if (score <= 5) {
                return 'background: #00ff88;';
            } else if (score <= 25) {
                return `background: linear-gradient(to right, #00ff88 0%, #00ff88 ${safeEnd - 10}%, #fbbf24 100%);`;
            } else if (score <= 50) {
                return `background: linear-gradient(to right, #00ff88 0%, #00ff88 ${Math.max(0, safeEnd - 15)}%, #fbbf24 ${safeEnd + 10}%, #f97316 100%);`;
            } else if (score <= 75) {
                return `background: linear-gradient(to right, #00ff88 0%, #00ff88 ${Math.max(0, safeEnd - 10)}%, #fbbf24 ${safeEnd}%, #f97316 ${safeEnd + 15}%, #ef4444 100%);`;
            } else {
                return `background: linear-gradient(to right, #00ff88 0%, #fbbf24 ${safeEnd}%, #f97316 ${safeEnd + 8}%, #ef4444 ${safeEnd + 16}%, #ef4444 100%);`;
            }
        }

        function openSidebar(country) {
            const sb = document.getElementById('threat-sidebar');
            document.getElementById('sidebar-country').textContent = country.name;
            document.getElementById('sidebar-code').textContent = country.code + ' — Threat Level: ' + getThreatLevel(country.overall);

            const domains = [
                { name: 'Physical Security', key: 'physical' },
                { name: 'Political Stability', key: 'political' },
                { name: 'Economic Freedom', key: 'economic' },
                { name: 'Digital Sovereignty', key: 'digital' },
                { name: 'Health & Environment', key: 'health' },
                { name: 'Social Cohesion', key: 'social' },
                { name: 'Mobility & Exit', key: 'mobility' },
                { name: 'Infrastructure', key: 'infrastructure' }
            ];

            let html = '';
            domains.forEach(d => {
                const val = country[d.key] || 0;
                const riskLabel = val <= 10 ? 'Minimal Risk' : val <= 25 ? 'Fairly Safe' : val <= 40 ? 'Moderate Risk' : val <= 55 ? 'Elevated Risk' : val <= 70 ? 'High Risk' : val <= 85 ? 'Severe Risk' : 'Extreme Risk';
                const barStyle = getThreatBarStyle(val);
                html += `<div class="domain-row">
                    <div class="domain-label"><span>${d.name}</span><span class="domain-score" style="color:${getThreatColorCSS(val)}">${val}/100 — ${riskLabel}</span></div>
                    <div class="threat-bar"><div class="threat-bar-fill" style="${barStyle}"></div></div>
                </div>`;
            });
            // Genocide risk as a full threat bar in domains (if applicable)
            if (country.genocide && country.genocide > 0) {
                const genocideScore = Math.round(country.genocide * 10); // Convert 0-10 to 0-100 scale
                const genocideLabel = genocideScore <= 10 ? 'Minimal Risk' : genocideScore <= 25 ? 'Fairly Safe' : genocideScore <= 40 ? 'Moderate Risk' : genocideScore <= 55 ? 'Elevated Risk' : genocideScore <= 70 ? 'High Risk' : genocideScore <= 85 ? 'Severe Risk' : 'Extreme Risk';
                const genocideBarStyle = getThreatBarStyle(genocideScore);
                const stageNames = ['Not applicable','Classification','Symbolization','Discrimination','Dehumanization','Organization','Polarization','Preparation','Persecution','Extermination','Denial'];
                const stageName = stageNames[Math.min(country.genocide, 10)] || 'Unknown';
                html += `<div class="domain-row">
                    <div class="domain-label"><span>⚠ Genocide Risk (Stage ${country.genocide}: ${stageName})</span><span class="domain-score" style="color:${country.genocide >= 4 ? '#ef4444' : country.genocide >= 2 ? '#f97316' : '#e5e7eb'}">${genocideScore}/100 — ${genocideLabel}</span></div>
                    <div class="threat-bar"><div class="threat-bar-fill" style="${genocideBarStyle}"></div></div>
                </div>`;
            }
            document.getElementById('sidebar-domains').innerHTML = html;

            let extras = '<div class="sidebar-section">ADDITIONAL INDICATORS</div>';
            extras += `<div class="sidebar-detail"><span>Genocide Stage</span><span style="color:${country.genocide >= 4 ? '#ef4444' : '#e5e7eb'}">${country.genocide}/10</span></div>`;
            extras += `<div class="sidebar-detail"><span>CBDC Status</span><span>${country.cbdc}</span></div>`;
            extras += `<div class="sidebar-detail"><span>Surveillance</span><span style="color:${getThreatColorCSS(country.surveillance)}">${country.surveillance}/100</span></div>`;
            extras += `<div class="sidebar-detail"><span>Cash Freedom</span><span style="color:${getThreatColorCSS(100-country.cashFreedom)}">${country.cashFreedom}/100</span></div>`;
            document.getElementById('sidebar-extras').innerHTML = extras;

            const level = getThreatLevel(country.overall);
            const badgeColors = { GREEN: '#00ff88', YELLOW: '#fbbf24', ORANGE: '#f97316', RED: '#ef4444' };
            const badge = document.getElementById('sidebar-badge');
            badge.style.background = badgeColors[level] || '#00ff88';
            badge.style.color = '#0a0e17';
            badge.textContent = `Threat Level: ${country.overall}/100 — ${getThreatLabel(country.overall)}`;

            sb.classList.add('open');
        }

        function closeSidebar() {
            document.getElementById('threat-sidebar').classList.remove('open');
        }

        // ===== Mouse =====
        function onMouseDown(e) {
            isDragging = true;
            velocityX = 0;
            velocityY = 0;
            previousMouse = { x: e.clientX, y: e.clientY };
            dragStartTime = Date.now();
            // Lock drag mode at start of drag based on where the mouse is
            dragMode = getDragMode(e.clientX);
        }

        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            if (isDragging && !isAnimating) {
                const dx = e.clientX - previousMouse.x;
                const dy = e.clientY - previousMouse.y;

                if (dragMode === 'zroll-left' || dragMode === 'zroll-right') {
                    // Z-roll zone: vertical drag rotates around Z axis
                    applyZRollRotation(dy, dragMode);
                } else {
                    // Normal globe drag: Y axis (horizontal) and X axis (vertical)
                    applyDragRotation(dx, dy);

                    // Track velocity for momentum
                    const radPerPx = getRadiansPerPixel();
                    const zoomFactor = cameraDistance / DEFAULT_ZOOM;
                    velocityX = dx * radPerPx * zoomFactor;
                    velocityY = dy * radPerPx * zoomFactor;
                }

                previousMouse = { x: e.clientX, y: e.clientY };
            }

            // Tooltip
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects([...countryMarkers, ...hotspotMarkers]);
            const tooltip = document.getElementById('tooltip');
            if (hits.length > 0 && hits[0].object.userData) {
                const d = hits[0].object.userData;
                if (d.isHotspot) {
                    tooltip.innerHTML = `<div class="country-name">${d.name}</div>
                        <div class="score-row"><span class="score-label">Type:</span><span>${d.type}</span></div>
                        <div class="score-row"><span class="score-label">Severity:</span><span style="color:${getThreatColorCSS(d.severity)}">${d.severity}</span></div>
                        <div class="score-row"><span class="score-label">Incidents (90d):</span><span>${d.incidents}</span></div>`;
                } else if (d.code) {
                    tooltip.innerHTML = `<div class="country-name">${d.name} (${d.code})</div>
                        <div class="score-row"><span class="score-label">Threat:</span><span style="color:${getThreatColorCSS(d.overall)}">${d.overall}/100 ${getThreatLevel(d.overall)}</span></div>
                        <div style="color:#9ca3af;font-size:10px;margin-top:4px">Click for details</div>`;
                } else { tooltip.style.display='none'; return; }
                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX+15)+'px';
                tooltip.style.top = (e.clientY+15)+'px';
            } else {
                tooltip.style.display = 'none';
            }
        }

        function onMouseUp() {
            if (isDragging) {
                isDragging = false;
                if (Date.now() - dragStartTime < 50) {
                    velocityX = 0;
                    velocityY = 0;
                }
            }
        }

        function onClick(e) {
            if (isAnimating) return;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(countryMarkers);
            if (hits.length > 0 && hits[0].object.userData && hits[0].object.userData.code) {
                const country = hits[0].object.userData;

                // Stop auto-rotation so user can inspect
                autoRotate = false;
                velocityX = 0;
                velocityY = 0;
                var btn = document.getElementById('rotate-btn');
                btn.classList.remove('active');
                btn.textContent = '⟳ Rotation Off';

                // Open sidebar immediately, then fly smoothly after panel appears
                openSidebar(country);
                setTimeout(() => smoothFlyTo(country.lat, country.lng, CONTINENT_ZOOM, 0.018), 150);
            }
        }

        // Smooth zoom target — actual cameraDistance lerps toward this each frame
        let targetZoomDistance = DEFAULT_ZOOM;

        function onMouseWheel(e) {
            if (isAnimating) return;
            // Multiplicative zoom for smooth feel
            const zoomFactor = 1 + e.deltaY * 0.001;
            targetZoomDistance = Math.max(6, Math.min(25, targetZoomDistance * zoomFactor));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ===== Animation =====
        function animate() {
            requestAnimationFrame(animate);

            // Smooth zoom interpolation
            if (!isAnimating) {
                const zoomDiff = targetZoomDistance - cameraDistance;
                if (Math.abs(zoomDiff) > 0.001) {
                    cameraDistance += zoomDiff * 0.12; // lerp factor
                    camera.position.set(0, 0, cameraDistance);
                    updateMarkerScales();
                    updateLOD();
                }
            }

            if (!isDragging && !isAnimating) {
                if (Math.abs(velocityX) > MIN_VELOCITY || Math.abs(velocityY) > MIN_VELOCITY) {
                    const qY = new THREE.Quaternion();
                    qY.setFromAxisAngle(new THREE.Vector3(0, 1, 0), velocityX);
                    const qX = new THREE.Quaternion();
                    qX.setFromAxisAngle(new THREE.Vector3(1, 0, 0), velocityY);
                    globeGroup.quaternion.premultiply(qY);
                    globeGroup.quaternion.premultiply(qX);
                    globeGroup.quaternion.normalize();
                    velocityX *= FRICTION;
                    velocityY *= FRICTION;
                    if (Math.abs(velocityX) < MIN_VELOCITY) velocityX = 0;
                    if (Math.abs(velocityY) < MIN_VELOCITY) velocityY = 0;
                } else if (autoRotate) {
                    const qAutoRotate = new THREE.Quaternion();
                    qAutoRotate.setFromAxisAngle(new THREE.Vector3(0, 1, 0), 0.0005);
                    globeGroup.quaternion.premultiply(qAutoRotate);
                    globeGroup.quaternion.normalize();
                }
            }

            const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
            hotspotMarkers.forEach(m => { if (m.material) m.material.opacity = pulse; });
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
