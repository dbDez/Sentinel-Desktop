<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SENTINEL Globe</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e17; overflow: hidden; font-family: 'Consolas', monospace; }
        #globe-container { width: 100vw; height: 100vh; }
        canvas { display: block; }

        #tooltip {
            position: absolute; display: none;
            background: rgba(17,24,39,0.95); border: 1px solid #00ff88;
            border-radius: 6px; padding: 10px 14px; color: #e5e7eb;
            font-size: 12px; pointer-events: none; z-index: 100; max-width: 280px;
        }
        #tooltip .country-name { font-size: 14px; font-weight: bold; color: #00ff88; margin-bottom: 6px; }
        #tooltip .score-row { display: flex; justify-content: space-between; margin: 2px 0; }
        #tooltip .score-label { color: #9ca3af; }
        #tooltip .score-value { font-weight: bold; }

        #continent-buttons {
            position: absolute; bottom: 20px; left: 20px;
            display: flex; gap: 6px; z-index: 50;
        }
        .continent-btn {
            background: rgba(26,31,46,0.9); border: 1px solid #1e293b;
            color: #e5e7eb; padding: 6px 12px; border-radius: 4px;
            cursor: pointer; font-size: 11px; font-family: 'Consolas', monospace; transition: all 0.2s;
        }
        .continent-btn:hover { border-color: #00ff88; color: #00ff88; background: rgba(0,255,136,0.1); }
        .continent-btn.active { border-color: #00ff88; color: #00ff88; background: rgba(0,255,136,0.2); }

        #controls {
            position: absolute; top: 10px; right: 10px;
            display: flex; flex-direction: column; gap: 6px; z-index: 50;
        }
        #info-panel {
            background: rgba(17,24,39,0.9); border: 1px solid #1e293b;
            border-radius: 6px; padding: 10px; color: #9ca3af; font-size: 10px;
        }
        .ctrl-btn {
            background: rgba(26,31,46,0.9); border: 1px solid #1e293b;
            color: #9ca3af; padding: 6px 12px; border-radius: 4px;
            cursor: pointer; font-size: 11px; font-family: 'Consolas', monospace; transition: all 0.2s;
        }
        .ctrl-btn:hover { border-color: #00ff88; color: #00ff88; }
        .ctrl-btn.active { background: rgba(0,255,136,0.15); border-color: #00ff88; color: #00ff88; }

        /* ===== THREAT SIDEBAR ===== */
        #threat-sidebar {
            position: absolute; top: 0; right: -380px; width: 380px; height: 100%;
            background: rgba(17,24,39,0.97); border-left: 1px solid #1e293b;
            z-index: 200; transition: right 0.35s ease; overflow-y: auto;
            padding: 16px; display: flex; flex-direction: column;
        }
        #threat-sidebar.open { right: 0; }
        #sidebar-close {
            position: absolute; top: 10px; right: 14px;
            background: none; border: 1px solid #1e293b; color: #9ca3af;
            font-size: 18px; cursor: pointer; border-radius: 4px; width: 28px; height: 28px;
            display: flex; align-items: center; justify-content: center; transition: all 0.2s;
        }
        #sidebar-close:hover { border-color: #ef4444; color: #ef4444; }
        #sidebar-country { font-size: 18px; font-weight: bold; color: #00ff88; margin-bottom: 4px; margin-right: 40px; }
        #sidebar-code { font-size: 12px; color: #9ca3af; margin-bottom: 16px; }
        .domain-row { margin-bottom: 14px; }
        .domain-label { font-size: 11px; color: #9ca3af; margin-bottom: 3px; display: flex; justify-content: space-between; }
        .domain-score { font-weight: bold; }
        .threat-bar {
            width: 100%; height: 12px; border-radius: 6px; position: relative;
            border: 1px solid rgba(255,255,255,0.06); overflow: hidden;
        }
        .threat-bar-fill {
            width: 100%; height: 100%;
            border-radius: 6px;
        }

        #sidebar-badge {
            margin-top: auto; padding: 10px; border-radius: 6px; text-align: center;
            font-size: 16px; font-weight: bold;
        }
        .sidebar-section { font-size: 11px; color: #fbbf24; font-weight: bold; margin: 12px 0 6px; }
        .sidebar-detail { font-size: 11px; color: #9ca3af; margin: 3px 0; display: flex; justify-content: space-between; }
        .sidebar-detail span:last-child { color: #e5e7eb; font-weight: bold; }

        #watermark {
            position: absolute; bottom: 20px; right: 20px; opacity: 0.35;
            pointer-events: none; z-index: 50;
        }
        #watermark img { filter: drop-shadow(0 0 8px rgba(0,255,136,0.3)); }
    </style>
</head>
<body>
    <div id="globe-container"></div>
    <div id="tooltip"></div>

    <div id="continent-buttons">
        <button class="continent-btn" data-continent="Africa" onclick="selectContinent(0, 20, 'Africa', this)">Africa</button>
        <button class="continent-btn" data-continent="Asia" onclick="selectContinent(35, 90, 'Asia', this)">Asia</button>
        <button class="continent-btn" data-continent="Europe" onclick="selectContinent(50, 15, 'Europe', this)">Europe</button>
        <button class="continent-btn" data-continent="NAmerica" onclick="selectContinent(40, -100, 'N.America', this)">N.America</button>
        <button class="continent-btn" data-continent="SAmerica" onclick="selectContinent(-15, -60, 'S.America', this)">S.America</button>
        <button class="continent-btn" data-continent="Oceania" onclick="selectContinent(-25, 135, 'Oceania', this)">Oceania</button>
        <button class="ctrl-btn" onclick="showAll()">üåê Show All</button>
    </div>

    <div id="controls">
        <div id="info-panel">
            <div>Drag to rotate | Scroll to zoom</div>
            <div>Click country marker for details</div>
        </div>
        <button class="ctrl-btn active" id="rotate-btn" onclick="toggleAutoRotate()">‚ü≥ Auto Rotate</button>
    </div>

    <!-- Threat Sidebar -->
    <div id="threat-sidebar">
        <button id="sidebar-close" onclick="closeSidebar()">‚úï</button>
        <div id="sidebar-country"></div>
        <div id="sidebar-code"></div>
        <div id="sidebar-domains"></div>
        <div id="sidebar-extras"></div>
        <div id="sidebar-badge"></div>
    </div>

    <div id="watermark">
        <img src="Sentinel.png" alt="Sentinel" width="48" height="48"/>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, globeGroup, globe, countryMarkers = [], hotspotMarkers = [];
        let countryData = [], hotspotData = [];
        let autoRotate = true, isDragging = false, isAnimating = false;
        let previousMouse = { x: 0, y: 0 };
        let dragStartTime = 0;
        let dragMode = 'normal'; // 'normal', 'zroll-left', or 'zroll-right'
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const GLOBE_RADIUS = 5;
        const MARKER_SIZE = 0.1;
        const DEFAULT_ZOOM = 15;
        const CONTINENT_ZOOM = 9;
        const DEG = Math.PI / 180;

        // Camera distance
        let cameraDistance = DEFAULT_ZOOM;

        // Momentum / inertia
        let velocityX = 0;
        let velocityY = 0;
        const FRICTION = 0.95;
        const MIN_VELOCITY = 0.0001;

        // Globe readiness
        let globeReady = false;

        // LOD texture management ‚Äî loaded lazily AFTER globe is interactive
        let currentLOD = 0;
        let globeMaterial = null;
        const textureLoader = new THREE.TextureLoader();
        let maxAniso = 1;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0e17);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, DEFAULT_ZOOM);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('globe-container').appendChild(renderer.domElement);

            maxAniso = renderer.capabilities.getMaxAnisotropy();

            scene.add(new THREE.AmbientLight(0xffffff, 1.2));
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(5, 3, 5);
            scene.add(sunLight);

            globeGroup = new THREE.Group();
            scene.add(globeGroup);

            // Earth ‚Äî load base texture, globe is usable immediately once this loads
            const earthTexture = textureLoader.load(
                'https://unpkg.com/three-globe@2.31.1/example/img/earth-blue-marble.jpg',
                function(tex) {
                    tex.anisotropy = maxAniso;
                    // Globe is now ready for markers
                    globeReady = true;
                    window.chrome.webview.postMessage('GLOBE_READY');
                }
            );
            const bumpTexture = textureLoader.load(
                'https://unpkg.com/three-globe@2.31.1/example/img/earth-topology.png',
                function(tex) { tex.anisotropy = maxAniso; }
            );

            const globeGeometry = new THREE.SphereGeometry(GLOBE_RADIUS, 128, 128);
            globeMaterial = new THREE.MeshPhongMaterial({
                map: earthTexture,
                bumpMap: bumpTexture,
                bumpScale: 0.05,
                specular: new THREE.Color(0x111827),
                shininess: 8,
                color: new THREE.Color(0.55, 0.55, 0.65)
            });
            globe = new THREE.Mesh(globeGeometry, globeMaterial);
            globeGroup.add(globe);

            // Atmosphere glow
            const atmosGeo = new THREE.SphereGeometry(GLOBE_RADIUS + 0.15, 64, 64);
            const atmosMat = new THREE.MeshBasicMaterial({
                color: 0x4488ff, transparent: true, opacity: 0.08, side: THREE.BackSide
            });
            scene.add(new THREE.Mesh(atmosGeo, atmosMat));

            // Stars
            const starsGeo = new THREE.BufferGeometry();
            const positions = [];
            for (let i = 0; i < 3000; i++) {
                positions.push((Math.random()-0.5)*300, (Math.random()-0.5)*300, (Math.random()-0.5)*300);
            }
            starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            scene.add(new THREE.Points(starsGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.08, transparent: true, opacity: 0.6 })));

            // Set initial rotation to show Africa/Europe on load
            setGlobeToLatLon(0, 0);

            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mouseleave', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('click', onClick);
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        // ===== LOD texture management ‚Äî loaded lazily after markers are shown =====
        let lodLoaded = false;
        const LOD_TEXTURES = [
            { zoom: 25, tex: null, bump: null, loaded: true }, // LOD 0 = base texture (already loaded)
            { zoom: 11, tex: null, bump: null, loaded: false,
              url: 'https://unpkg.com/three-globe@2.31.3/example/img/earth-blue-marble.jpg',
              bumpUrl: 'https://unpkg.com/three-globe@2.31.3/example/img/earth-topology.png' },
            { zoom: 7, tex: null, bump: null, loaded: false,
              url: 'https://unpkg.com/three-globe@2.34.2/example/img/earth-blue-marble.jpg',
              bumpUrl: 'https://unpkg.com/three-globe@2.34.2/example/img/earth-topology.png' }
        ];

        function startLODPreload() {
            if (lodLoaded) return;
            lodLoaded = true;
            // LOD 0 is already the base texture on the globe
            LOD_TEXTURES[0].tex = globeMaterial.map;
            LOD_TEXTURES[0].bump = globeMaterial.bumpMap;

            for (let i = 1; i < LOD_TEXTURES.length; i++) {
                (function(idx) {
                    textureLoader.load(LOD_TEXTURES[idx].url, function(tex) {
                        tex.anisotropy = maxAniso;
                        LOD_TEXTURES[idx].tex = tex;
                        LOD_TEXTURES[idx].loaded = true;
                    });
                    textureLoader.load(LOD_TEXTURES[idx].bumpUrl, function(tex) {
                        tex.anisotropy = maxAniso;
                        LOD_TEXTURES[idx].bump = tex;
                    });
                })(i);
            }
        }

        function updateLOD() {
            let bestLOD = 0;
            for (let i = LOD_TEXTURES.length - 1; i >= 0; i--) {
                if (cameraDistance <= LOD_TEXTURES[i].zoom && LOD_TEXTURES[i].loaded && LOD_TEXTURES[i].tex) {
                    bestLOD = i;
                    break;
                }
            }
            if (bestLOD !== currentLOD && LOD_TEXTURES[bestLOD].tex) {
                currentLOD = bestLOD;
                globeMaterial.map = LOD_TEXTURES[bestLOD].tex;
                globeMaterial.map.needsUpdate = true;
                if (LOD_TEXTURES[bestLOD].bump) {
                    globeMaterial.bumpMap = LOD_TEXTURES[bestLOD].bump;
                    globeMaterial.bumpMap.needsUpdate = true;
                }
                globeMaterial.needsUpdate = true;
            }
        }

        // ===== Marker scaling =====
        // Scale markers inversely proportional to zoom so they appear constant
        // size on screen at default zoom, and shrink when zooming in.
        function getMarkerScale() {
            // At DEFAULT_ZOOM (15) ‚Üí scale 1.0
            // At min zoom (7) ‚Üí scale ~0.47 (markers shrink as you get closer)
            return cameraDistance / DEFAULT_ZOOM;
        }

        function updateMarkerScales() {
            const s = getMarkerScale();
            countryMarkers.forEach(m => {
                m.scale.set(s, s, s);
            });
            hotspotMarkers.forEach(m => {
                m.scale.set(s, s, s);
            });
        }

        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * DEG;
            const theta = (lon + 180) * DEG;
            return new THREE.Vector3(
                -(radius * Math.sin(phi) * Math.cos(theta)),
                radius * Math.cos(phi),
                radius * Math.sin(phi) * Math.sin(theta)
            );
        }

        // Build a quaternion for a given lat/lon that guarantees NO Z-roll.
        function quaternionForLatLon(lat, lon) {
            const qY = new THREE.Quaternion();
            qY.setFromAxisAngle(new THREE.Vector3(0, 1, 0), -(90 + lon) * DEG);
            const qX = new THREE.Quaternion();
            qX.setFromAxisAngle(new THREE.Vector3(1, 0, 0), lat * DEG);
            const q = qY.clone();
            q.premultiply(qX);
            return q;
        }

        function setGlobeToLatLon(lat, lon) {
            globeGroup.quaternion.copy(quaternionForLatLon(lat, lon));
        }

        // Called from C# to set the home position (gentle smooth animation)
        function setHomePosition(lat, lon) {
            smoothFlyTo(lat, lon, DEFAULT_ZOOM, 0.012);
        }

        function getThreatColor(score) {
            if (score >= 76) return 0xef4444;
            if (score >= 51) return 0xf97316;
            if (score >= 26) return 0xfbbf24;
            return 0x00ff88;
        }
        function getThreatColorCSS(score) {
            if (score >= 76) return '#ef4444';
            if (score >= 51) return '#f97316';
            if (score >= 26) return '#fbbf24';
            return '#00ff88';
        }
        function getThreatLevel(score) {
            if (score >= 76) return 'RED';
            if (score >= 51) return 'ORANGE';
            if (score >= 26) return 'YELLOW';
            return 'GREEN';
        }
        function getThreatLabel(score) {
            if (score >= 86) return 'Extreme Risk';
            if (score >= 71) return 'Severe Risk';
            if (score >= 56) return 'High Risk';
            if (score >= 41) return 'Elevated Risk';
            if (score >= 26) return 'Moderate Risk';
            if (score >= 11) return 'Fairly Safe';
            return 'Minimal Risk';
        }

        // ===== Data Loading =====
        function loadCountryData(data) {
            countryData = data;
            countryMarkers.forEach(m => globeGroup.remove(m));
            countryMarkers = [];

            data.forEach(country => {
                const pos = latLonToVector3(country.lat, country.lng, GLOBE_RADIUS + 0.01);
                const color = getThreatColor(country.overall);

                const geo = new THREE.SphereGeometry(MARKER_SIZE, 12, 12);
                const mat = new THREE.MeshBasicMaterial({ color: color });
                const marker = new THREE.Mesh(geo, mat);
                marker.position.copy(pos);
                marker.userData = country;
                globeGroup.add(marker);
                countryMarkers.push(marker);

                if (country.overall >= 51) {
                    const ringGeo = new THREE.RingGeometry(MARKER_SIZE * 1.5, MARKER_SIZE * 2.2, 16);
                    const ringMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.4, side: THREE.DoubleSide });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.position.copy(pos);
                    ring.lookAt(new THREE.Vector3(0,0,0));
                    globeGroup.add(ring);
                    countryMarkers.push(ring);
                }
            });

            updateMarkerScales();

            // Start preloading higher LOD textures now that markers are visible
            setTimeout(startLODPreload, 500);
        }

        function loadHotspotData(data) {
            hotspotData = data;
            hotspotMarkers.forEach(m => globeGroup.remove(m));
            hotspotMarkers = [];

            data.forEach(hotspot => {
                const pos = latLonToVector3(hotspot.lat, hotspot.lng, GLOBE_RADIUS + 0.02);
                const geo = new THREE.SphereGeometry(MARKER_SIZE * 0.5, 6, 6);
                const mat = new THREE.MeshBasicMaterial({ color: 0xff2222, transparent: true });
                const marker = new THREE.Mesh(geo, mat);
                marker.position.copy(pos);
                marker.userData = { ...hotspot, isHotspot: true };
                globeGroup.add(marker);
                hotspotMarkers.push(marker);
            });

            updateMarkerScales();
        }

        // ===== Continent Selection & Fly-To =====
        function selectContinent(lat, lon, label, btn) {
            document.querySelectorAll('.continent-btn').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');
            velocityX = 0;
            velocityY = 0;
            smoothFlyTo(lat, lon, CONTINENT_ZOOM);
        }

        function showAll() {
            document.querySelectorAll('.continent-btn').forEach(b => b.classList.remove('active'));
            closeSidebar();
            velocityX = 0;
            velocityY = 0;
            smoothFlyTo(0, 0, DEFAULT_ZOOM);
        }

        // Smooth fly-to with slerp. speed parameter controls animation rate (default 0.025).
        function smoothFlyTo(lat, lon, zoom, speed) {
            const step_speed = speed || 0.025;
            isAnimating = true;
            const startQ = globeGroup.quaternion.clone();
            const targetQ = quaternionForLatLon(lat, lon);

            if (startQ.dot(targetQ) < 0) {
                targetQ.set(-targetQ.x, -targetQ.y, -targetQ.z, -targetQ.w);
            }

            const startZoom = cameraDistance;
            const targetZoom = zoom;

            let t = 0;
            function step() {
                t += step_speed;
                if (t >= 1) {
                    t = 1;
                    globeGroup.quaternion.copy(quaternionForLatLon(lat, lon));
                    cameraDistance = targetZoom;
                    camera.position.set(0, 0, cameraDistance);
                    camera.lookAt(0, 0, 0);
                    updateMarkerScales();
                    updateLOD();
                    isAnimating = false;
                    return;
                }
                const ease = t < 0.5 ? 2*t*t : -1+(4-2*t)*t;
                globeGroup.quaternion.slerpQuaternions(startQ, targetQ, ease);
                cameraDistance = startZoom + (targetZoom - startZoom) * ease;
                camera.position.set(0, 0, cameraDistance);
                camera.lookAt(0, 0, 0);
                updateMarkerScales();
                updateLOD();
                requestAnimationFrame(step);
            }
            step();
        }

        // ===== Controls =====
        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            const btn = document.getElementById('rotate-btn');
            btn.classList.toggle('active', autoRotate);
            btn.textContent = autoRotate ? '‚ü≥ Auto Rotate' : '‚ü≥ Rotation Off';
        }

        // ===== Drag rotation =====
        function getRadiansPerPixel() {
            const vFov = camera.fov * DEG;
            const visibleHeight = 2 * Math.tan(vFov / 2) * cameraDistance;
            const globeDiameterPx = (2 * GLOBE_RADIUS / visibleHeight) * window.innerHeight;
            return Math.PI / globeDiameterPx;
        }

        // Get the pixel X boundaries of the globe's visible disc on screen.
        // Returns { left, right, centerX } in client pixels.
        function getGlobeScreenBounds() {
            const vFov = camera.fov * DEG;
            const visibleHeight = 2 * Math.tan(vFov / 2) * cameraDistance;
            const visibleWidth = visibleHeight * (window.innerWidth / window.innerHeight);
            const pxPerUnit = window.innerWidth / visibleWidth;
            const globeRadiusPx = GLOBE_RADIUS * pxPerUnit;
            const centerX = window.innerWidth / 2;
            return {
                left: centerX - globeRadiusPx,
                right: centerX + globeRadiusPx,
                centerX: centerX,
                radiusPx: globeRadiusPx
            };
        }

        // Determine drag mode based on mouse X position relative to globe edges.
        // Z-roll zones start at 1.5√ó globe radius from center (well beyond the globe edge).
        function getDragMode(clientX) {
            const bounds = getGlobeScreenBounds();
            const zZoneMargin = bounds.radiusPx * 0.5; // Z-zone starts half a radius beyond the globe edge
            const zZoneLeft = bounds.left - zZoneMargin;
            const zZoneRight = bounds.right + zZoneMargin;
            if (clientX < zZoneLeft) {
                return 'zroll-left';
            }
            if (clientX > zZoneRight) {
                return 'zroll-right';
            }
            return 'normal';
        }

        // Apply drag rotation: Y-axis (horizontal) and X-axis (vertical) in world space.
        // This is the proven working approach ‚Äî premultiply world-space quaternions.
        function applyDragRotation(dx, dy) {
            const radPerPx = getRadiansPerPixel();
            const angleY = dx * radPerPx;
            const angleX = dy * radPerPx;

            if (Math.abs(angleY) > 0.000001) {
                const qY = new THREE.Quaternion();
                qY.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angleY);
                globeGroup.quaternion.premultiply(qY);
            }

            if (Math.abs(angleX) > 0.000001) {
                const qX = new THREE.Quaternion();
                qX.setFromAxisAngle(new THREE.Vector3(1, 0, 0), angleX);
                globeGroup.quaternion.premultiply(qX);
            }

            globeGroup.quaternion.normalize();
        }

        // Apply Z-axis roll rotation (for Z-roll drag zones)
        // side: 'zroll-left' or 'zroll-right' ‚Äî right side needs inverted direction
        function applyZRollRotation(dy, side) {
            const radPerPx = getRadiansPerPixel();
            const direction = (side === 'zroll-right') ? -1 : 1;
            const angleZ = dy * radPerPx * direction;
            if (Math.abs(angleZ) > 0.000001) {
                const qZ = new THREE.Quaternion();
                qZ.setFromAxisAngle(new THREE.Vector3(0, 0, 1), angleZ);
                globeGroup.quaternion.premultiply(qZ);
                globeGroup.quaternion.normalize();
            }
        }

        // ===== Threat Sidebar =====
        function getThreatBarStyle(score) {
            const safeEnd = Math.max(0, 100 - score);

            if (score <= 5) {
                return 'background: #00ff88;';
            } else if (score <= 25) {
                return `background: linear-gradient(to right, #00ff88 0%, #00ff88 ${safeEnd - 10}%, #fbbf24 100%);`;
            } else if (score <= 50) {
                return `background: linear-gradient(to right, #00ff88 0%, #00ff88 ${Math.max(0, safeEnd - 15)}%, #fbbf24 ${safeEnd + 10}%, #f97316 100%);`;
            } else if (score <= 75) {
                return `background: linear-gradient(to right, #00ff88 0%, #00ff88 ${Math.max(0, safeEnd - 10)}%, #fbbf24 ${safeEnd}%, #f97316 ${safeEnd + 15}%, #ef4444 100%);`;
            } else {
                return `background: linear-gradient(to right, #00ff88 0%, #fbbf24 ${safeEnd}%, #f97316 ${safeEnd + 8}%, #ef4444 ${safeEnd + 16}%, #ef4444 100%);`;
            }
        }

        function openSidebar(country) {
            const sb = document.getElementById('threat-sidebar');
            document.getElementById('sidebar-country').textContent = country.name;
            document.getElementById('sidebar-code').textContent = country.code + ' ‚Äî Threat Level: ' + getThreatLevel(country.overall);

            const domains = [
                { name: 'Physical Security', key: 'physical' },
                { name: 'Political Stability', key: 'political' },
                { name: 'Economic Freedom', key: 'economic' },
                { name: 'Digital Sovereignty', key: 'digital' },
                { name: 'Health & Environment', key: 'health' },
                { name: 'Social Cohesion', key: 'social' },
                { name: 'Mobility & Exit', key: 'mobility' },
                { name: 'Infrastructure', key: 'infrastructure' }
            ];

            let html = '';
            domains.forEach(d => {
                const val = country[d.key] || 0;
                const riskLabel = val <= 10 ? 'Minimal Risk' : val <= 25 ? 'Fairly Safe' : val <= 40 ? 'Moderate Risk' : val <= 55 ? 'Elevated Risk' : val <= 70 ? 'High Risk' : val <= 85 ? 'Severe Risk' : 'Extreme Risk';
                const barStyle = getThreatBarStyle(val);
                html += `<div class="domain-row">
                    <div class="domain-label"><span>${d.name}</span><span class="domain-score" style="color:${getThreatColorCSS(val)}">${val}/100 ‚Äî ${riskLabel}</span></div>
                    <div class="threat-bar"><div class="threat-bar-fill" style="${barStyle}"></div></div>
                </div>`;
            });
            document.getElementById('sidebar-domains').innerHTML = html;

            let extras = '<div class="sidebar-section">ADDITIONAL INDICATORS</div>';
            extras += `<div class="sidebar-detail"><span>Genocide Stage</span><span style="color:${country.genocide >= 4 ? '#ef4444' : '#e5e7eb'}">${country.genocide}/10</span></div>`;
            extras += `<div class="sidebar-detail"><span>CBDC Status</span><span>${country.cbdc}</span></div>`;
            extras += `<div class="sidebar-detail"><span>Surveillance</span><span style="color:${getThreatColorCSS(country.surveillance)}">${country.surveillance}/100</span></div>`;
            extras += `<div class="sidebar-detail"><span>Cash Freedom</span><span style="color:${getThreatColorCSS(100-country.cashFreedom)}">${country.cashFreedom}/100</span></div>`;
            document.getElementById('sidebar-extras').innerHTML = extras;

            const level = getThreatLevel(country.overall);
            const badgeColors = { GREEN: '#00ff88', YELLOW: '#fbbf24', ORANGE: '#f97316', RED: '#ef4444' };
            const badge = document.getElementById('sidebar-badge');
            badge.style.background = badgeColors[level] || '#00ff88';
            badge.style.color = '#0a0e17';
            badge.textContent = `Threat Level: ${country.overall}/100 ‚Äî ${getThreatLabel(country.overall)}`;

            sb.classList.add('open');
        }

        function closeSidebar() {
            document.getElementById('threat-sidebar').classList.remove('open');
        }

        // ===== Mouse =====
        function onMouseDown(e) {
            isDragging = true;
            velocityX = 0;
            velocityY = 0;
            previousMouse = { x: e.clientX, y: e.clientY };
            dragStartTime = Date.now();
            // Lock drag mode at start of drag based on where the mouse is
            dragMode = getDragMode(e.clientX);
        }

        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            if (isDragging && !isAnimating) {
                const dx = e.clientX - previousMouse.x;
                const dy = e.clientY - previousMouse.y;

                if (dragMode === 'zroll-left' || dragMode === 'zroll-right') {
                    // Z-roll zone: vertical drag rotates around Z axis
                    applyZRollRotation(dy, dragMode);
                } else {
                    // Normal globe drag: Y axis (horizontal) and X axis (vertical)
                    applyDragRotation(dx, dy);

                    // Track velocity for momentum
                    const radPerPx = getRadiansPerPixel();
                    velocityX = dx * radPerPx;
                    velocityY = dy * radPerPx;
                }

                previousMouse = { x: e.clientX, y: e.clientY };
            }

            // Tooltip
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects([...countryMarkers, ...hotspotMarkers]);
            const tooltip = document.getElementById('tooltip');
            if (hits.length > 0 && hits[0].object.userData) {
                const d = hits[0].object.userData;
                if (d.isHotspot) {
                    tooltip.innerHTML = `<div class="country-name">${d.name}</div>
                        <div class="score-row"><span class="score-label">Type:</span><span>${d.type}</span></div>
                        <div class="score-row"><span class="score-label">Severity:</span><span style="color:${getThreatColorCSS(d.severity)}">${d.severity}</span></div>
                        <div class="score-row"><span class="score-label">Incidents (90d):</span><span>${d.incidents}</span></div>`;
                } else if (d.code) {
                    tooltip.innerHTML = `<div class="country-name">${d.name} (${d.code})</div>
                        <div class="score-row"><span class="score-label">Threat:</span><span style="color:${getThreatColorCSS(d.overall)}">${d.overall}/100 ${getThreatLevel(d.overall)}</span></div>
                        <div style="color:#9ca3af;font-size:10px;margin-top:4px">Click for details</div>`;
                } else { tooltip.style.display='none'; return; }
                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX+15)+'px';
                tooltip.style.top = (e.clientY+15)+'px';
            } else {
                tooltip.style.display = 'none';
            }
        }

        function onMouseUp() {
            if (isDragging) {
                isDragging = false;
                if (Date.now() - dragStartTime < 50) {
                    velocityX = 0;
                    velocityY = 0;
                }
            }
        }

        function onClick(e) {
            if (isAnimating) return;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(countryMarkers);
            if (hits.length > 0 && hits[0].object.userData && hits[0].object.userData.code) {
                openSidebar(hits[0].object.userData);
            }
        }

        function onMouseWheel(e) {
            if (isAnimating) return;
            cameraDistance += e.deltaY * 0.01;
            cameraDistance = Math.max(7, Math.min(25, cameraDistance));
            camera.position.set(0, 0, cameraDistance);
            updateMarkerScales();
            updateLOD();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ===== Animation =====
        function animate() {
            requestAnimationFrame(animate);

            if (!isDragging && !isAnimating) {
                if (Math.abs(velocityX) > MIN_VELOCITY || Math.abs(velocityY) > MIN_VELOCITY) {
                    const qY = new THREE.Quaternion();
                    qY.setFromAxisAngle(new THREE.Vector3(0, 1, 0), velocityX);
                    const qX = new THREE.Quaternion();
                    qX.setFromAxisAngle(new THREE.Vector3(1, 0, 0), velocityY);
                    globeGroup.quaternion.premultiply(qY);
                    globeGroup.quaternion.premultiply(qX);
                    globeGroup.quaternion.normalize();
                    velocityX *= FRICTION;
                    velocityY *= FRICTION;
                    if (Math.abs(velocityX) < MIN_VELOCITY) velocityX = 0;
                    if (Math.abs(velocityY) < MIN_VELOCITY) velocityY = 0;
                } else if (autoRotate) {
                    const qAutoRotate = new THREE.Quaternion();
                    qAutoRotate.setFromAxisAngle(new THREE.Vector3(0, 1, 0), 0.0005);
                    globeGroup.quaternion.premultiply(qAutoRotate);
                    globeGroup.quaternion.normalize();
                }
            }

            const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
            hotspotMarkers.forEach(m => { if (m.material) m.material.opacity = pulse; });
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
